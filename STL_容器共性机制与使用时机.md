# STL_容器共性机制与使用时机

### 一、容器的共通能力

C++模板是容器的概念。                            

理论提高：所有容器提供的都是值（value）语意，而非引用（reference）语意。**容器执行插入元素的操作时，内部实施拷贝动作。**所以STL容器内存储的元素必须**能够被拷贝**（必须提供拷贝构造函数）。

 除了queue与stack外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。

通常STL不会丢出异常，要求使用者确保传入正确的参数。

每个容器都提供了一个默认构造函数跟一个默认拷贝构造函数。

如已有容器vecIntA。 

```cpp
vector<int> vecIntB(vecIntA); //调用拷贝构造函数，复制vecIntA到vecIntB中。
```

与大小相关的操作方法(c代表容器)：

```cpp
c.size();  //返回容器中元素的个数
c.empty();  //判断容器是否为空
```

比较操作(c1,c2代表容器)：

```cpp
c1 == c2   //判断c1是否等于c2
c1 != c2   //判断c1是否不等于c2
c1 = c2    //把c2的所有元素指派给c1 
```



### 二、STL容器使用时机

| .            | vector   | deque    | list     | set    | multiset | map           | multimap      |
| ------------ | -------- | -------- | -------- | ------ | -------- | ------------- | ------------- |
| 典型内存结构 | 单端数组 | 双端数组 | 双向链表 | 二叉树 | 二叉树   | 二叉树        | 二叉树        |
| 可随机存取   | 是       | 是       | 否       | 否     | 否       | 对key而言：是 | 否            |
| 元素搜寻速度 | 慢       | 慢       | 非常慢   | 快     | 快       | 对key而言：快 | 对key而言：快 |
| 元素安插移除 | 尾端     | 头尾两端 | 任何位置 | -      | -        | -             | -             |

vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。

deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。

vector与deque的比较：

- 一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置 却是不固定的。
- 二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。
- 三：deque支持头部的快速插入与快速移除，这是deque的优点。

list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。

set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。

map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。